### 查找

#### 一、顺序表

##### 顺序表的查找

###### 效率分析

查找成功：ASL = (n+1) / 2

查找失败：ASL =  n + 1

###### 优化方法

- 优化查找失败：对于有序的顺序表，查到比想找的元素大的，就停止。

  ASL<sub>失败</sub> = (1+2+...+n+n)/(n+1) = n/2 + n/(n+1) 

- 优化查找成功：被查概率不相等：被查概率大的放到靠前位置。





##### 有序表的折半查找（仅适用于有序顺序表）

被查元素不断和 mid = (low + high) / 2 位置的元素进行比较，过程中修正 low 和 high。

###### 算法实现

- 迭代：while(low <= high) 其中先定义mid，再判断elem[mid] == key就return；否则，调整low或high
- 递归： 终止条件：查找失败，low > high；查找成功，low = high = mid

###### 效率分析

基于查找判定树分析：最多的比较次数即树高：log<sub>2</sub>(n+1) 向**上**取整。且 n个结点的二叉树，失败结点有n+1个。

ASL<sub>成功</sub>, ASL<sub>失败</sub> 均 < h = log<sub>2</sub>(n+1) 向**上**取整，所以**时间复杂度 O(log<sub>2</sub>n)**

-----------------------------------------------------------------------------------------------------

*高为h的二叉树最多2<sup>h</sup>-1个结点，最少2<sup>h-1</sup> - 1 个结点。

所以有n个结点的二叉树，2<sup>h-1</sup> - 1 < n  ≤ 2<sup>h</sup>-1  =>  h-1 < log<sub>2</sub>(n+1) ≤ h

------------------------------------------------------------------------------------------------------------

